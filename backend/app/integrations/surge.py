"""SURGE OpenClaw tokenization service — full EVM launch flow on Base."""

import os
import hashlib
import httpx
from typing import Optional, Dict, Any
from app.logger import get_logger

logger = get_logger(__name__)

_PLACEHOLDER_KEY = "your_surge_api_key_here"
# Default EIDO logo — DiceBear served via Cloudflare CDN, globally accessible.
_DEFAULT_LOGO_URL = "https://api.dicebear.com/7.x/initials/png?seed=EIDO&size=400"


class SurgeTokenManager:
    """
    Manages full SURGE OpenClaw token launch lifecycle on Base (EVM).

    Flow per call to create_token():
      0. GET  /openclaw/launch-info          → live fee + chainId
      1. POST /openclaw/wallet/create        → create / retrieve EVM wallet
      2. POST /openclaw/wallet/{id}/fund     → one-time free funding (idempotent)
      3. GET  /openclaw/wallet/{id}/balance  → verify sufficient balance
      4. POST /openclaw/launch               → launch token on bonding curve
    """

    BASE_URL = "https://back.surge.xyz"

    def __init__(self, api_key: Optional[str] = None):
        raw = api_key or os.getenv("SURGE_API_KEY", "")
        self.api_key: Optional[str] = raw if raw and raw != _PLACEHOLDER_KEY else None
        self.timeout = 30.0
        # Cached wallet id so we reuse the same wallet across multiple calls
        self._wallet_id: Optional[str] = None
        self._wallet_address: Optional[str] = None

    async def create_token(
        self,
        mvp_id: int,
        name: str,
        symbol: str = "MVP",
        description: Optional[str] = None,
        logo_url: Optional[str] = None,
        category: str = "ai",
    ) -> Dict[str, Any]:
        """Create a SURGE token for an MVP."""
        if not self.api_key:
            logger.warning("SURGE_API_KEY not configured — returning mock token")
            return self._mock(mvp_id, name, symbol)

        safe_description = description or f"Autonomous MVP generated by EIDO: {name}"
        safe_logo = logo_url or _DEFAULT_LOGO_URL
        safe_symbol = (symbol or "MVP").upper()[:5]

        async with httpx.AsyncClient(timeout=self.timeout) as client:
            try:
                # Step 0 — live config
                launch_info = await self._get_launch_info(client)
                chains = launch_info.get("chains", [])
                base_chain = next((c for c in chains if c.get("chainName") == "Base"), None)
                if not base_chain:
                    raise ValueError(f"Base chain not found. Available: {[c.get('chainName') for c in chains]}")

                chain_id = str(base_chain["chainId"])
                fee = base_chain.get("fee", "0.005")
                # Initial buy must be > fee. When fee is 0 (free launch), use a small
                # positive amount that fits within the platform-funded wallet balance (~0.00006 ETH).
                try:
                    fee_f = float(fee)
                    if fee_f <= 0:
                        eth_amount = "0.00005"   # safe within ~0.000062 ETH free funding
                    else:
                        eth_amount = f"{fee_f * 2:.6f}".rstrip("0").rstrip(".")
                except Exception:
                    eth_amount = "0.01"
                logger.info(f"SURGE chain={chain_id} fee={fee} ethAmount={eth_amount}")

                # Step 1 — wallet create / retrieve
                wallet_id = await self._create_wallet(client)

                # Step 2 — one-time free funding (idempotent)
                await self._fund_wallet(client, wallet_id)

                # Step 3 — balance check (non-blocking; server validates anyway)
                await self._check_balance(client, wallet_id)

                # Step 4 — launch
                result = await self._launch(
                    client, wallet_id, chain_id, eth_amount,
                    name, safe_symbol, safe_description, safe_logo, category,
                )
                logger.info(f"SURGE launch response: {result}")

                token_address = result.get("tokenAddress") or result.get("contractAddress") or ""
                tx_hash = result.get("txHash", "")
                explorer_url = result.get("explorerUrl", "")
                surge_url = f"https://app.surge.xyz/trade/{token_address}" if token_address else ""

                return {
                    "token_id": f"SURGE-{mvp_id:04d}",
                    "contract_address": token_address,
                    "token_address": token_address,
                    "name": result.get("tokenName", name),
                    "symbol": result.get("tokenTicker", safe_symbol),
                    "tx_hash": tx_hash,
                    "chain": result.get("chainName", "Base"),
                    "surge_url": surge_url,
                    "explorer_url": explorer_url,
                    "wallet_id": wallet_id,
                    "status": "live",
                    "summary": result.get("summary", f"Token {name} ({safe_symbol}) launched on Base."),
                }

            except httpx.HTTPStatusError as e:
                body = ""
                try:
                    body = e.response.text
                except Exception:
                    pass
                logger.error(f"SURGE HTTP error {e.response.status_code}: {body}")
                # Image proxy issue — wallet funded, flow works; mark pending not failed
                is_proxy_issue = "Proxy connection timed out" in body or "Failed to download" in body
                status = "pending" if is_proxy_issue else "failed"
                if is_proxy_issue:
                    logger.warning("SURGE image proxy is broken — token is pending launch; wallet is funded")
                return {**self._mock(mvp_id, name, symbol), "status": status, "error": body}

            except Exception as e:
                logger.error(f"SURGE create_token failed: {e}")
                return {**self._mock(mvp_id, name, symbol), "status": "failed", "error": str(e)}

    def _mock(self, mvp_id: int, name: str, symbol: str) -> Dict[str, Any]:
        # Deterministic but realistic-looking address derived from name + id
        h = hashlib.sha256(f"{mvp_id}:{name}:{symbol}".encode()).hexdigest()
        addr = "0x" + h[:40]
        safe_symbol = (symbol or "MVP").upper()[:5]
        return {
            "token_id": f"SURGE-{mvp_id:04d}",
            "contract_address": addr,
            "token_address": addr,
            "name": name,
            "symbol": safe_symbol,
            "chain": "Base",
            "wallet_id": self._wallet_id or "",
            "wallet_address": self._wallet_address or "",
            "status": "mocked",
            "surge_url": f"https://app.surge.xyz/trade/{addr}",
            "explorer_url": f"https://basescan.org/address/{addr}",
            "summary": f"Token {name} ({safe_symbol}) prepared for launch on Base via SURGE.",
        }

    def _headers(self) -> Dict[str, str]:
        return {"X-API-Key": self.api_key, "Content-Type": "application/json"}

    async def _get_launch_info(self, client: httpx.AsyncClient) -> Dict[str, Any]:
        r = await client.get(f"{self.BASE_URL}/openclaw/launch-info",
                             headers=self._headers(), timeout=self.timeout)
        r.raise_for_status()
        return r.json()

    async def _create_wallet(self, client: httpx.AsyncClient) -> str:
        if self._wallet_id:
            return self._wallet_id
        r = await client.post(f"{self.BASE_URL}/openclaw/wallet/create",
                              headers=self._headers(), timeout=self.timeout)
        r.raise_for_status()
        data = r.json()
        self._wallet_id = data["walletId"]
        self._wallet_address = data.get("address", "")
        logger.info(f"SURGE wallet: {self._wallet_id} addr={self._wallet_address} new={data.get('isNew')}")
        return self._wallet_id

    async def _fund_wallet(self, client: httpx.AsyncClient, wallet_id: str) -> None:
        try:
            r = await client.post(
                f"{self.BASE_URL}/openclaw/wallet/{wallet_id}/fund",
                headers=self._headers(), timeout=self.timeout,
            )
            data = r.json()
            logger.info(f"SURGE funding response: {data.get('funding') or data.get('message') or data}")
        except Exception as e:
            logger.warning(f"SURGE funding failed (continuing): {e}")

    async def _check_balance(self, client: httpx.AsyncClient, wallet_id: str) -> bool:
        try:
            r = await client.get(
                f"{self.BASE_URL}/openclaw/wallet/{wallet_id}/balance",
                headers=self._headers(), timeout=self.timeout,
            )
            r.raise_for_status()
            data = r.json()
            balances = data if isinstance(data, list) else data.get("balances", [])
            for bal in balances:
                if bal.get("chainName") == "Base":
                    sufficient = bal.get("sufficient", False)
                    logger.info(f"SURGE balance Base: {bal.get('balance')} ETH sufficient={sufficient}")
                    return sufficient
            return False
        except Exception as e:
            logger.warning(f"SURGE balance check failed (continuing): {e}")
            return False

    async def _launch(
        self,
        client: httpx.AsyncClient,
        wallet_id: str,
        chain_id: str,
        eth_amount: str,
        name: str,
        symbol: str,
        description: str,
        logo_url: str,
        category: str = "ai",
    ) -> Dict[str, Any]:
        payload = {
            "name": name,
            "ticker": symbol,
            "description": description,
            "logoUrl": logo_url,
            "chainId": chain_id,
            "walletId": wallet_id,
            "ethAmount": eth_amount,
            "category": category,
        }
        logger.info(f"SURGE /openclaw/launch payload: {payload}")
        r = await client.post(
            f"{self.BASE_URL}/openclaw/launch",
            headers=self._headers(),
            json=payload,
            timeout=60.0,
        )
        r.raise_for_status()
        return r.json()

    async def set_metadata(self, token_id: str, metadata: Dict[str, Any]) -> bool:
        """No-op — SURGE metadata is set at launch time."""
        return True

    async def publish(self, token_id: str) -> bool:
        """No-op — tokens are live on app.surge.xyz immediately after launch."""
        return True
